library(jsonlite)
#Load properties file
#Nabbed from http://stackoverflow.com/questions/13681310/reading-configuration-from-text-file
# myProp <- read.table("config.txt", header=FALSE, sep="=", row.names=1, strip.white=TRUE, na.strings="NA", stringsAsFactors=FALSE)
# myProp <- setNames(myProp[,1],row.names(myProp))
# myProp["dateOfLastLimitBreach"]
#record of failed calls
fail = 0
#Base URL, will knock query together below
testURL <- "http://maps.googleapis.com/maps/api/distancematrix/json"
#Use single shapefile of Great Britain
gbmerge <- readOGR(dsn="GB_merged", "GB_merged")
#Store the points
#Number of origin-destination pairs to create and fetch
#Note there's a pause of at least 0.2 seconds between each
#so getting >2000 of your daily google API allowance
#Might be around 7 minutes
#The csv won't be saved until the end of the process
#Job: add option to save regularly so's not to risk wasting API call limit
#DAILY ALLOWANCE IS 2500.
pairNum = 2000
#http://casoilresource.lawr.ucdavis.edu/drupal/book/export/html/644
#sp package has specific tool for spatial sampling within polygons. Hooray!
randomPointOrigins <- spsample(gbmerge, n=pairNum, type='random')
randomPointDestinations <- spsample(gbmerge, n=pairNum, type='random')
#In case you wanna see em
#plot(gbmerge); points(randomPointDestinations, col='red', pch=3, cex=0.5); points(randomPointOrigins, col='blue', pch=3, cex=0.5)
#convert to lat long in prep for google query
randomPointOrigins <- spTransform(randomPointOrigins, CRS("+init=epsg:4326"))
randomPointDestinations <- spTransform(randomPointDestinations, CRS("+init=epsg:4326"))
#Use dataframe, single row per origin-destination pair
randomPointOrigins <- data.frame(randomPointOrigins)
randomPointDestinations <- data.frame(randomPointDestinations)
#Distinguish x and y column names (for later CSV writing)
colnames(randomPointOrigins)[colnames(randomPointOrigins)=="x"] <- "origin_x"
colnames(randomPointOrigins)[colnames(randomPointOrigins)=="y"] <- "origin_y"
colnames(randomPointDestinations)[colnames(randomPointDestinations)=="x"] <- "dest_x"
colnames(randomPointDestinations)[colnames(randomPointDestinations)=="y"] <- "dest_y"
#Final set of origin-destination points
pointSet <- cbind(randomPointOrigins,randomPointDestinations)
#Create results matrix, one row per origin-destination pair
#Storing four results: distance and time of each route
#(Distance in metres, time in seconds)
#And also the strings for the address of origins and destinations
results <- matrix(nrow=pairNum , ncol=4)
#Iterate over required pair numbers, get data from google
for(i in 1:pairNum) {
#set google distance matrix query
#Google does y,x. Reverse order
#See https://developers.google.com/maps/documentation/distancematrix/ for option info
qry <- paste("origins=", pointSet[i,2] , "," , pointSet[i,1] ,
"&destinations=" ,pointSet[i,4] , "," , pointSet[i,3] ,
"&sensor=FALSE",
#              "&mode=bicycling",
"&avoid=ferries",#not going to any islands!
sep=""#no spaces
)
#Get the JSON
gimme <- GET(
testURL,
query = qry,
#If using in Leeds University, obv: comment this out if not, or if using Leeds Uni wifi
#Use this to see details of proxy connection: c(use_proxy("www-cache.leeds.ac.uk:3128", 8080), verbose())
c(use_proxy("www-cache.leeds.ac.uk:3128", 8080))
)
#http://blog.rstudio.org/2014/03/21/httr-0-3/
stop_for_status(gimme)
store <- content(gimme)
#if result was OK, keep
# if(store$status=="OK") {
if(store$rows[[1]]$elements[[1]]$status=="OK") {
results[i,1] <- store$rows[[1]]$elements[[1]]$distance$value
results[i,2] <- store$rows[[1]]$elements[[1]]$duration$value
results[i,3] <- store$origin_addresses[[1]]
results[i,4] <- store$destination_addresses[[1]]
} else {
fail <- fail + 1
}
#pause between API calls. We're aiming for:
# "100 elements per 10 seconds."
# "2500 elements per 24 hour period."
#Two elements per call (origin and destination)
#Being conservative: 0.3 seconds should hit ~66 elements per 10 seconds
Sys.sleep(0.3)
print(paste("API call", i, "complete, status: ", store$rows[[1]]$elements[[1]]$status))
}#end for
#Append the coordinates used
readyForWriting <- cbind(data.frame(results),pointSet)
colnames(readyForWriting)[colnames(readyForWriting)=="X1"] <- "distance"
colnames(readyForWriting)[colnames(readyForWriting)=="X2"] <- "time"
colnames(readyForWriting)[colnames(readyForWriting)=="X3"] <- "origin"
colnames(readyForWriting)[colnames(readyForWriting)=="X4"] <- "destination"
#Strip out failed calls
readyForWriting <- readyForWriting[ !is.na(readyForWriting$distance) ,]
#Write the final results file, unique name each time
filename = paste("GoogleDistanceMatrixRandomPathRresults_",date(),".csv",sep="")
#spaces with underscores
filename <- gsub(" ", "_", filename)
#colons with underscores
filename <- gsub(":", "_", filename)
write.csv(readyForWriting, filename)
print(paste(pairNum, "attempts, ", (pairNum - fail), "successful."))
print(paste("File written: ", filename))
routes <- rbind(read.csv("latestrbindOfMatrixOutputs.csv"), read.csv("GoogleDistanceMatrixRandomPathRresults_Wed_May_21_18_06_23_2014.csv"))
write.csv(routes, "latestrbindOfMatrixOutputs.csv")
nrow(routes)
histyprinty <- ggplot(routes, aes(x=distance/1000)) +
#   scale_x_continuous(trans=log2_trans()) +
#   coord_cartesian(xlim = c(0, 10)) +
ggtitle(" ") +
theme(plot.title = element_text(lineheight=1.5, face="bold")) +
#   theme_classic() +
xlab("distance (km)") +
#   ylab("number of individual flows") +
#   geom_histogram(colour="white", fill="black")
geom_histogram(colour="white", fill="black", binwidth = 25) +
geom_vline(xintercept=mean(routes$distance/1000), color="red")
#   geom_histogram(colour="white", fill="black", binwidth = 0.75)
#           geom_histogram(aes(fill = value))
histyprinty
library(ggplot2)
library(reshape)
library(scales)
setwd("C:/Users/geodo/Dropbox/R/Workspace/randomNetworkDistancer")
histyprinty <- ggplot(routes, aes(x=distance/1000)) +
#   scale_x_continuous(trans=log2_trans()) +
#   coord_cartesian(xlim = c(0, 10)) +
ggtitle(" ") +
theme(plot.title = element_text(lineheight=1.5, face="bold")) +
#   theme_classic() +
xlab("distance (km)") +
#   ylab("number of individual flows") +
#   geom_histogram(colour="white", fill="black")
geom_histogram(colour="white", fill="black", binwidth = 25) +
geom_vline(xintercept=mean(routes$distance/1000), color="red")
#   geom_histogram(colour="white", fill="black", binwidth = 0.75)
#           geom_histogram(aes(fill = value))
histyprinty
histyprinty <- ggplot(routes, aes(x=distance/1000)) +
#   scale_x_continuous(trans=log2_trans()) +
#   coord_cartesian(xlim = c(0, 10)) +
ggtitle(" ") +
theme(plot.title = element_text(lineheight=1.5, face="bold")) +
#   theme_classic() +
xlab("distance (km)") +
#   ylab("number of individual flows") +
#   geom_histogram(colour="white", fill="black")
geom_histogram(colour="white", fill="black", binwidth = 30) +
geom_vline(xintercept=mean(routes$distance/1000), color="red")
#   geom_histogram(colour="white", fill="black", binwidth = 0.75)
#           geom_histogram(aes(fill = value))
histyprinty
histyprinty <- ggplot(routes, aes(x=distance/1000)) +
#   scale_x_continuous(trans=log2_trans()) +
#   coord_cartesian(xlim = c(0, 10)) +
ggtitle(" ") +
theme(plot.title = element_text(lineheight=1.5, face="bold")) +
#   theme_classic() +
xlab("distance (km)") +
#   ylab("number of individual flows") +
#   geom_histogram(colour="white", fill="black")
geom_histogram(colour="white", fill="black", binwidth = 25) +
geom_vline(xintercept=mean(routes$distance/1000), color="red")
#   geom_histogram(colour="white", fill="black", binwidth = 0.75)
#           geom_histogram(aes(fill = value))
histyprinty
output <- ggplot(routes, aes(x = factor(1), y = (distance/1000))) +
geom_boxplot(outlier.size = 3) +
ggtitle(" ") +
theme(plot.title = element_text(lineheight=.8, face="bold")) +
xlab(" ") +
ylab("Distance")
output
maxDist <- max(routes$distance)
maxTime <- max(routes$time)
normedDistTime <- routes
normedDistTime$distance <- normedDistTime$distance/maxDist
normedDistTime$time <- normedDistTime$time/maxTime
#melt is very clever!
normedDistTime <- melt(normedDistTime, id="X", measure=c("distance","time"))
output <- ggplot(normedDistTime, aes(x = variable, y = value)) +
geom_boxplot(outlier.size = 3) +
ggtitle(" ") +
theme(plot.title = element_text(lineheight=.8, face="bold")) +
xlab(" ") +
ylab("normalised values") +
coord_flip()
output
nrow(routes)
setwd("C:/Users/geodo/Dropbox/R/Workspace/randomNetworkDistancer")
library(ggplot2)
library(reshape)
library(scales)
#Get last two...
#routes <- rbind(read.csv("latestrbindOfMatrixOutputs.csv"), read.csv("GoogleDistanceMatrixRandomPathRresults_Wed_May_21_18_06_23_2014.csv"))
#write.csv(routes, "latestrbindOfMatrixOutputs.csv")
routes <- read.csv("latestrbindOfMatrixOutputs.csv")
#Lets just check the basics
output <- ggplot(routes, aes(x = factor(1), y = (distance/1000))) +
geom_boxplot(outlier.size = 3) +
ggtitle(" ") +
theme(plot.title = element_text(lineheight=.8, face="bold")) +
xlab(" ") +
ylab("Distance")
output
histyprinty <- ggplot(routes, aes(x=distance/1000)) +
#   scale_x_continuous(trans=log2_trans()) +
#   coord_cartesian(xlim = c(0, 10)) +
ggtitle(" ") +
theme(plot.title = element_text(lineheight=1.5, face="bold")) +
#   theme_classic() +
xlab("distance (km)") +
#   ylab("number of individual flows") +
#   geom_histogram(colour="white", fill="black")
geom_histogram(colour="white", fill="black", binwidth = 25) +
geom_vline(xintercept=mean(routes$distance/1000), color="red")
#   geom_histogram(colour="white", fill="black", binwidth = 0.75)
#           geom_histogram(aes(fill = value))
histyprinty
histyprinty <- ggplot(routes, aes(x=distance/1000)) +
#   scale_x_continuous(trans=log2_trans()) +
#   coord_cartesian(xlim = c(0, 10)) +
ggtitle(" ") +
theme(plot.title = element_text(lineheight=1.5, face="bold")) +
#   theme_classic() +
xlab("distance (km)") +
#   ylab("number of individual flows") +
#   geom_histogram(colour="white", fill="black")
geom_histogram(colour="white", fill="black", binwidth = 25) +
geom_vline(xintercept=mean(routes$distance/1000), color="red")
#   geom_histogram(colour="white", fill="black", binwidth = 0.75)
#           geom_histogram(aes(fill = value))
histyprinty
ggsave(histyprinty, file="randomisedDistanceRoutesUK.png", width=8, height=5, dpi = 600)
library(ggplot2)
library(reshape)
library(scales)
histyprinty <- ggplot(routes, aes(x=distance/1000)) +
#   scale_x_continuous(trans=log2_trans()) +
#   coord_cartesian(xlim = c(0, 10)) +
ggtitle(" ") +
theme(plot.title = element_text(lineheight=1.5, face="bold")) +
#   theme_classic() +
xlab("distance (km)") +
#   ylab("number of individual flows") +
#   geom_histogram(colour="white", fill="black")
geom_histogram(colour="white", fill="black", binwidth = 25) +
geom_vline(xintercept=mean(routes$distance/1000), color="red")
#   geom_histogram(colour="white", fill="black", binwidth = 0.75)
#           geom_histogram(aes(fill = value))
histyprinty
ggsave(histyprinty, file="randomisedDistanceRoutesUK.png", width=8, height=5, dpi = 600)
ggsave(histyprinty, file="randomisedDistanceRoutesUK.png", width=6, height=4, dpi = 600)
setwd("C:/Users/geodo/Dropbox/R/Workspace/randomNetworkDistancer")
library(ggplot2)
library(reshape)
library(scales)
#Get last two...
#routes <- rbind(read.csv("latestrbindOfMatrixOutputs.csv"), read.csv("GoogleDistanceMatrixRandomPathRresults_Wed_May_21_18_06_23_2014.csv"))
#write.csv(routes, "latestrbindOfMatrixOutputs.csv")
routes <- read.csv("latestrbindOfMatrixOutputs.csv")
#Lets just check the basics
output <- ggplot(routes, aes(x = factor(1), y = (distance/1000))) +
geom_boxplot(outlier.size = 3) +
ggtitle(" ") +
theme(plot.title = element_text(lineheight=.8, face="bold")) +
xlab(" ") +
ylab("Distance")
output
setwd("C:/Users/geodo/Dropbox/R/Workspace/randomNetworkDistancer")
library(ggplot2)
library(reshape)
library(scales)
#Get last two...
#routes <- rbind(read.csv("latestrbindOfMatrixOutputs.csv"), read.csv("GoogleDistanceMatrixRandomPathRresults_Wed_May_21_18_06_23_2014.csv"))
#write.csv(routes, "latestrbindOfMatrixOutputs.csv")
routes <- read.csv("latestrbindOfMatrixOutputs.csv")
#Lets just check the basics
output <- ggplot(routes, aes(x = factor(1), y = (distance/1000))) +
geom_boxplot(outlier.size = 3) +
ggtitle(" ") +
theme(plot.title = element_text(lineheight=.8, face="bold")) +
xlab(" ") +
ylab("Distance")
output
.libPaths()
install.packages("Rccp")
install.packages("Rcpp")
setwd("C:/Users/geodo/Dropbox/R/Workspace/randomNetworkDistancer")
library(ggplot2)
library(reshape)
library(scales)
#Get last two...
#routes <- rbind(read.csv("latestrbindOfMatrixOutputs.csv"), read.csv("GoogleDistanceMatrixRandomPathRresults_Wed_May_21_18_06_23_2014.csv"))
#write.csv(routes, "latestrbindOfMatrixOutputs.csv")
routes <- read.csv("latestrbindOfMatrixOutputs.csv")
#Lets just check the basics
output <- ggplot(routes, aes(x = factor(1), y = (distance/1000))) +
geom_boxplot(outlier.size = 3) +
ggtitle(" ") +
theme(plot.title = element_text(lineheight=.8, face="bold")) +
xlab(" ") +
ylab("Distance")
output
routes <- read.csv("latestrbindOfMatrixOutputs.csv")
View(routes)
library(sp)
install.packages("sp")
library(sp)
origins <- subset(routes, select = (origin_x, origin_y))
origins <- subset(routes, select = c(origin_x, origin_y))
View(origins)
dests <- subset(routes, select = c(dest_x, dest_y))
ll <- matrix(c(5, 6, 60, 60), ncol=2)
ll
km <- spDistsN1(routes[,7:8], routes[9,10], longlat=TRUE)
justcoords <- subset(routes, select = c(origin_x, origin_y, dest_x, dest_y))
heda(justcoords)
head(justcoords)
class(justcoords)
justcoords <- subset(routes, select = c(origin_x, origin_y, dest_x, dest_y))
justcoords <- data.matrix(justcoords)
head(justcoords)
class(justcoords)
km <- spDistsN1(justcoords[,1:2], justcoords[,3:4], longlat=TRUE)
origins <- data.matrix(subset(routes, select = c(origin_x, origin_y)))
dests <- data.matrix(subset(routes, select = c(dest_x, dest_y)))
km <- spDistsN1(origins, dests, longlat=TRUE)
km <- spDistsN1(origins[1,], dests[1,], longlat=TRUE)
km <- spDistsN1(origins, dests[1,], longlat=TRUE)
p1 = SpatialPoints(cbind(1:3, 1:3))
p1
spDists(p1)
spDists(p1, p1)
spDists(p1, p1, diagonal = TRUE)
try(spDists(p1, p1, segments = TRUE))
spDists(p1, segments = TRUE)
spDistsN1(p1)
spDistsN1(p1, p1)
spDistsN1(p1, p1[1,])
orig <- origins[,1]
class(orig)
orig
orig <- origins[1,]
orig
class(orig)
class(origins)
orig <- data.matrix(origins[1,])
class(orig)
routes$npDist <- 0
for (i in 1:length(origins)) {
#get a single pair, turn into matrix for spDistN1
orig <- data.matrix(origins[i,])
routes$npDist[i] <- npDistsN1(orig,dests[i,], longlat=TRUE)
}
for (i in 1:length(origins)) {
#get a single pair, turn into matrix for spDistN1
orig <- data.matrix(origins[i,])
routes$npDist[i] <- spDistsN1(orig,dests[i,], longlat=TRUE)
}
km <- spDistsN1(origins, dests[1,], longlat=TRUE)
km
routes$spDist <- 0
routes$spDist[1] <- spDistsN1(orig,dests[1,], longlat=TRUE)
orig
orig <- t(data.matrix(origins[1,]))
orig
routes$spDist[1] <- spDistsN1(orig,dests[1,], longlat=TRUE)
routes$spDist
routes$spDist[1]
for (i in 1:length(origins)) {
#get a single pair, turn into matrix for spDistN1
#needs transposing. Not sure why it doesn't keep the original orientation
orig <- t(data.matrix(origins[i,]))
routes$spDist[i] <- spDistsN1(orig,dests[i,], longlat=TRUE)
}
i
length(origins)
nrow(origins)
for (i in 1:nrow(origins)) {
#get a single pair, turn into matrix for spDistN1
#needs transposing. Not sure why it doesn't keep the original orientation
orig <- t(data.matrix(origins[i,]))
routes$spDist[i] <- spDistsN1(orig,dests[i,], longlat=TRUE)
}
View(routes)
plot(routes$distance, routes$spDist)
routes <- read.csv("latestrbindOfMatrixOutputs.csv")
#convert distance to kms
routes$distance <- routes$distance / 1000
#For ease of reading, let's subset to get the values we want
# origins <- subset(routes, select = c(origin_x, origin_y))
# dests <- subset(routes, select = c(dest_x, dest_y))
# justcoords <- subset(routes, select = c(origin_x, origin_y, dest_x, dest_y))
# justcoords <- data.matrix(justcoords)
origins <- data.matrix(subset(routes, select = c(origin_x, origin_y)))
dests <- data.matrix(subset(routes, select = c(dest_x, dest_y)))
routes$spDist <- 0
for (i in 1:nrow(origins)) {
#get a single pair, turn into matrix for spDistN1
#needs transposing. Not sure why it doesn't keep the original orientation
orig <- t(data.matrix(origins[i,]))
#spDistN1: first arg needs to be a matrix of points. Supplying it with a single-row matrix
#Second argument has to be a single point.
#If the first arg had more values it would find all dists between each of those and the single point
#But we only want each origin-destination pair distance
#http://rpackages.ianhowson.com/rforge/sp/man/spDistsN1.html
routes$spDist[i] <- spDistsN1(orig,dests[i,], longlat=TRUE)
}
plot(routes$distance, routes$spDist)
routes$rf <- spDist/distance
routes$rf <- routes$spDist/routes$distance
hist(routes$rf, breaks=30)
library(ggplot2)
summary(routes$rf)
install.packages(Hmisc)
install.packages("Hmisc")
routes$distbins <- as.numeric(cut2(routes$spDist, g=10))
library(Hmisc)#for binning distances
routes$distbins <- as.numeric(cut2(routes$spDist, g=10))
View(routes)
routes$distbinmeans <- tapply(routes$spDist, routes$distbins, mean)
rfhypo <- data.frame(c(1:10), c(1:10))
View(rfhypo)
distmean <- rep(0,10)
rfmean <- rep(0,10)
distmean <- rep(0,10)
rfmean <- rep(0,10)
rfhypo <- data.frame(distmean, rfmean)
View(rfhypo)
rfhypo$distmean <- tapply(routes$spDist, routes$distbins, mean)
bins = 10
rfhypo$rfmean <- tapply(routes$rf, routes$distbins, mean)
plot(rfhypo)
line(rfhypo, col="green")
lines(rfhypo, col="green")
hist(routes$rf, breaks=30)
bins = 10
#Hypothesis: route factor varies depending on distance. Lower distances have lower route factors.
#Use following to split into distance bins
#Then correlate average route factor per bin to average distance per bin
#http://stackoverflow.com/questions/6104836/splitting-a-continuous-variable-into-equal-sized-groups
routes$distbins <- as.numeric(cut2(routes$spDist, g=bins))
distmean <- rep(0,bins)
rfmean <- rep(0,bins)
rfhypo <- data.frame(distmean, rfmean)
#Use these bins to get average distance...
rfhypo$distmean <- tapply(routes$spDist, routes$distbins, mean)
#... and average route factor
rfhypo$rfmean <- tapply(routes$rf, routes$distbins, mean)
plot(rfhypo)
lines(rfhypo, col="green")
bins = 30
#Hypothesis: route factor varies depending on distance. Lower distances have lower route factors.
#Use following to split into distance bins
#Then correlate average route factor per bin to average distance per bin
#http://stackoverflow.com/questions/6104836/splitting-a-continuous-variable-into-equal-sized-groups
routes$distbins <- as.numeric(cut2(routes$spDist, g=bins))
distmean <- rep(0,bins)
rfmean <- rep(0,bins)
rfhypo <- data.frame(distmean, rfmean)
#Use these bins to get average distance...
rfhypo$distmean <- tapply(routes$spDist, routes$distbins, mean)
#... and average route factor
rfhypo$rfmean <- tapply(routes$rf, routes$distbins, mean)
plot(rfhypo)
lines(rfhypo, col="green")
bins = 20
#Hypothesis: route factor varies depending on distance. Lower distances have lower route factors.
#Use following to split into distance bins
#Then correlate average route factor per bin to average distance per bin
#http://stackoverflow.com/questions/6104836/splitting-a-continuous-variable-into-equal-sized-groups
routes$distbins <- as.numeric(cut2(routes$spDist, g=bins))
distmean <- rep(0,bins)
rfmean <- rep(0,bins)
rfhypo <- data.frame(distmean, rfmean)
#Use these bins to get average distance...
rfhypo$distmean <- tapply(routes$spDist, routes$distbins, mean)
#... and average route factor
rfhypo$rfmean <- tapply(routes$rf, routes$distbins, mean)
plot(rfhypo)
lines(rfhypo, col="green")
bins = 10
#Hypothesis: route factor varies depending on distance. Lower distances have lower route factors.
#Use following to split into distance bins
#Then correlate average route factor per bin to average distance per bin
#http://stackoverflow.com/questions/6104836/splitting-a-continuous-variable-into-equal-sized-groups
routes$distbins <- as.numeric(cut2(routes$spDist, g=bins))
distmean <- rep(0,bins)
rfmean <- rep(0,bins)
rfhypo <- data.frame(distmean, rfmean)
#Use these bins to get average distance...
rfhypo$distmean <- tapply(routes$spDist, routes$distbins, mean)
#... and average route factor
rfhypo$rfmean <- tapply(routes$rf, routes$distbins, mean)
plot(rfhypo)
lines(rfhypo, col="green")
bins = 30
#Hypothesis: route factor varies depending on distance. Lower distances have lower route factors.
#Use following to split into distance bins
#Then correlate average route factor per bin to average distance per bin
#http://stackoverflow.com/questions/6104836/splitting-a-continuous-variable-into-equal-sized-groups
routes$distbins <- as.numeric(cut2(routes$spDist, g=bins))
distmean <- rep(0,bins)
rfmean <- rep(0,bins)
rfhypo <- data.frame(distmean, rfmean)
#Use these bins to get average distance...
rfhypo$distmean <- tapply(routes$spDist, routes$distbins, mean)
#... and average route factor
rfhypo$rfmean <- tapply(routes$rf, routes$distbins, mean)
plot(rfhypo)
lines(rfhypo, col="green")

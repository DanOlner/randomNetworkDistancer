{
    "contents" : "library(rgdal)\nlibrary(rgeos)\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(reshape2)\n\n#apikey <- read.csv(\"apikey.csv\")\n#apikey <- apikey[1,]\n\n#Base URL, will knock query together below\ntestURL <- \"https://maps.googleapis.com/maps/api/distancematrix/json\"\n\nvenuesNPostcodes <- read.csv(\"tramlineVenues_n_Postcodes.csv\")\npostcodes <- venuesNPostcodes[,2]\n\npostcodes <- gsub(\" \", \"\", postcodes, fixed=TRUE)\nvenues <- venuesNPostcodes[,1]\n\n#turn postcodes into a melted list of pairs\n#(This is one way of avoiding the matrix API limits)\npostcodematrix <- matrix(nrow=length(postcodes) , ncol=length(postcodes))\nrownames(postcodematrix) <- postcodes\ncolnames(postcodematrix) <- postcodes\n\npostcodepairs <- melt(postcodematrix)\n\nresults <- matrix(nrow=nrow(postcodepairs) , ncol=4)\n\n#loop over pairs, thus only two `elements' per query\nfor(i in 1:nrow(postcodepairs)) {\n  \n\n#set google distance matrix query\n#See https://developers.google.com/maps/documentation/distancematrix/ for option info\nqry <- paste(\"origins=\", postcodepairs$Var1[i],\n             \"&destinations=\", postcodepairs$Var2[i] ,\n             \"&sensor=FALSE\",\n              \"&mode=walking\",\n             #\"&key=\",\n             #apikey,\n             sep=\"\"#no spaces\n)\n\n#Get the JSON\ngimme <- GET(\n  testURL,  \n  query = qry,\n  #If using in Leeds University, obv: comment this out if not, or if using Leeds Uni wifi\n  #Use this to see details of proxy connection: c(use_proxy(\"www-cache.leeds.ac.uk:3128\", 8080), verbose())\n  c(use_proxy(\"www-cache.leeds.ac.uk:3128\", 8080))\n)\n\n#http://blog.rstudio.org/2014/03/21/httr-0-3/\nstop_for_status(gimme)\n\nstore <- content(gimme)\n\n#Being conservative: 0.3 seconds should hit ~66 elements per 10 seconds\nSys.sleep(0.3)\n\nif(store$rows[[1]]$elements[[1]]$status==\"OK\") {\n  results[i,1] <- store$rows[[1]]$elements[[1]]$distance$value\n  results[i,2] <- store$rows[[1]]$elements[[1]]$duration$value\n  results[i,3] <- store$rows[[1]]$elements[[1]]$distance$text\n  results[i,4] <- store$rows[[1]]$elements[[1]]$duration$text\n} else {\n  results[i,1] <- \"xxx\"\n  results[i,2] <- \"xxx\"\n  results[i,3] <- \"xxx\"\n  results[i42] <- \"xxx\"\n}\n\n\n}#end for\n\n#just while I'm playing...\nresultsBackup <- results\n\n#get ride of odd diagonal. 1 minute to get to where I'm standing?\n#results[results == \"1 m\"] <- \"0\"\n#results[results == \"1 min\"] <- \"0 min\"\n\n#Just verbal description of time and distance\ntextresults <- results[,3:4]\n\ntextresults <- data.frame(textresults)\n\n#Foundry and fusion have the same postcode\n#need to add unique identifier to deal with that\ntextresults$id <- rep(1:16, times = 16)\n\n#join up postcodes. One matrix for distance, one for time\ndistance <- cbind(postcodepairs, textresults)\ndistance <- distance[,c(1,2,5,6)]\n\ndistancematrix <- dcast(distance, Var1 + id ~ Var2, value.var = \"X2\")\n\n\n\n\n\n\n#Add postcode labels\nrownames(distresultstext) <- postcodes\ncolnames(distresultstext) <- postcodes\n\nrownames(timeresultstext) <- postcodes\ncolnames(timeresultstext) <- postcodes\n\n#get ride of odd diagonal. 1 minute to get to where I'm standing?\ndistresultstext[distresultstext == \"1 m\"] <- \"0\"\ntimeresultstext[timeresultstext == \"1 min\"] <- \"0 min\"\n\nwrite.csv(distresultstext, file=\"distresults.csv\")\nwrite.csv(timeresultstext, file=\"timeresults.csv\")\n\n#Or use venue names, more logically!\nrownames(distresultstext) <- venues\ncolnames(distresultstext) <- venues\n\nrownames(timeresultstext) <- venues\ncolnames(timeresultstext) <- venues\n\nwrite.csv(distresultstext, file=\"distresults_venues.csv\")\nwrite.csv(timeresultstext, file=\"timeresults_venues.csv\")",
    "created" : 1434555129759.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1050766965",
    "id" : "10C6C49B",
    "lastKnownWriteTime" : 1436131277,
    "path" : "C:/Users/geodo/Dropbox/R/Workspace/randomNetworkDistancer/postCodeMatrixLimitRateThenBind.R",
    "project_path" : "postCodeMatrixLimitRateThenBind.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}